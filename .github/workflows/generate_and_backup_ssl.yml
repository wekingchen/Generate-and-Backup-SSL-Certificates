name: Generate and Backup SSL Certificates
on:
  schedule:
    - cron: "35 23 * * *"
  workflow_dispatch:

env:
  EMAIL: ${{ secrets.EMAIL }}
  CF_TOKEN: ${{ secrets.CF_TOKEN }}  # 添加 Cloudflare API Token
  CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}  # Cloudflare Account ID
  RCLONE_PARAMS: "--transfers=10 --checkers=10 --stats=1s"
  DROPBOX_PATH: "SSL"  # 将 DROPBOX_PATH 设置为 "SSL"
  DAYS_BEFORE_EXPIRY: 30
  ACME_PATH: "/home/runner/.acme.sh/acme.sh"

jobs:
  generate-and-backup:
    runs-on: ubuntu-latest
    name: Generate and Backup SSL Certificates
    steps:
      - name: Checkout master
        uses: actions/checkout@v4

      - name: Cache acme.sh
        uses: actions/cache@v4
        with:
          path: /home/runner/.acme.sh  # 使用绝对路径，仅缓存 acme.sh 目录
          key: ${{ runner.os }}-acme
          enableCrossOsArchive: false

      - name: Install rclone and acme.sh
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          curl https://rclone.org/install.sh | sudo bash
          curl https://get.acme.sh | sh -s email=$EMAIL
        
      - name: Configure rclone
        env:
          RCLONE_CONFIG: ${{ secrets.RCLONE_CONFIG }}
        run: |
          mkdir -p ~/.config/rclone
          echo "$RCLONE_CONFIG" > ~/.config/rclone/rclone.conf

      - name: Sync certificates from Dropbox
        run: |
          rclone sync dropbox:$DROPBOX_PATH ./ssl $RCLONE_PARAMS --log-file=rclone_sync.log || exit 1
          echo "SSL Certificates synced from Dropbox."

      - name: Generate SSL Certificates if needed
        env:
          CF_Token: ${{ secrets.CF_TOKEN }}  # 确保这些变量在生成证书时可用
          CF_Account_ID: ${{ secrets.CF_ACCOUNT_ID }}
        run: |
          check_certificate_validity() {
            cert_path=$1
            if [ -f "$cert_path" ]; then
              if openssl x509 -checkend $(( DAYS_BEFORE_EXPIRY * 86400 )) -noout -in "$cert_path"; then
                echo "Certificate at $cert_path is valid for more than $DAYS_BEFORE_EXPIRY days, skipping renewal..."
                return 0
              else
                return 1
              fi
            else
              return 1
            fi
          }

          issue_and_install_certificate() {
          domain=$1
          cert_type=$2  # "EC" 或 "RSA"
          cert_path="./ssl/$domain"
          [ "$cert_type" = "RSA" ] && cert_path="$cert_path/rsa"
          cert_file="$cert_path/$domain.cer"
          key_file="$cert_path/$domain.key"
          certificate_updated=false  # 标记是否更新证书

          # 独立检查每个证书类型的有效性
          if ! check_certificate_validity "$cert_file"; then
          echo "正在为 $domain 生成 $cert_type 证书..."
          # 使用 acme.sh 生成证书并捕获输出
          issue_output=$($ACME_PATH --issue --dns dns_cf -d "$domain" -d "*.$domain" 2>&1)
        
          # 如果已经存在有效证书，则跳过生成
          if echo "$issue_output" | grep -q 'Skipping. Next renewal time'; then
            echo "跳过 $domain 的证书更新，因为尚未到期。"
          elif echo "$issue_output" | grep -q 'success'; then
            $ACME_PATH --installcert -d "$domain" --key-file "$key_file" --fullchain-file "$cert_file" || { echo "无法为 $domain 安装证书"; return 1; }
            echo "已为 $domain 生成并安装 $cert_type 证书"
            certificate_updated=true  # 标记证书已更新
          else
            echo "无法为 $domain 生成证书"
            exit 1
          fi
          else
          echo "$domain 的现有 $cert_type 证书仍然有效，无需生成新证书。"
          fi

          echo $certificate_updated  # 返回证书是否更新状态
          }

          # 初始化更新标志和域名列表
          any_certificate_updated=false
          updated_domains=""  # 用于存储有更新的域名

          # 分别生成EC和RSA证书
          while IFS= read -r domain || [ -n "$domain" ]; do
          mkdir -p "./ssl/$domain/rsa"
          # 生成EC证书
          if issue_and_install_certificate "$domain" "EC"; then
          any_certificate_updated=true
          updated_domains="$updated_domains $domain"  # 添加更新的域名
          fi
          # 独立生成RSA证书
          if issue_and_install_certificate "$domain" "RSA"; then
          any_certificate_updated=true
          updated_domains="$updated_domains $domain"  # 添加更新的域名
          fi
          done < cloudflare_domains_list.txt || true

          # 如果有任何证书更新，且 updated_domains 不为空，发送BARK通知
          if [ "$any_certificate_updated" = true ] && [ -n "$updated_domains" ]; then
          BARK_URL="${{ secrets.BARK_URL }}"
          NOTIFICATION_TITLE="SSL证书已更新"
          NOTIFICATION_BODY="以下域名的SSL证书已成功更新: $updated_domains"
    
          # 检查 BARK_URL 和 NOTIFICATION_BODY 是否为空
          if [ -n "$BARK_URL" ] && [ -n "$NOTIFICATION_BODY" ]; then
          # 替换空格为URL编码的空格
          ENCODED_BODY=$(echo "$NOTIFICATION_BODY" | sed 's/ /%20/g')
          curl -X POST "$BARK_URL/$NOTIFICATION_TITLE/$ENCODED_BODY"
          else
          echo "BARK_URL 或 NOTIFICATION_BODY 为空，跳过通知。"
          fi
          else
          echo "没有证书更新，跳过通知。"
          fi

      - name: Validate new certificates
        run: |
          for cert in $(find ./ssl -name "*.cer"); do
            openssl x509 -in "$cert" -noout -text || { echo "Invalid certificate: $cert"; exit 1; }
          done
          echo "All certificates are valid."

      - name: Backup certificates to Dropbox
        run: |
          rclone sync ./ssl dropbox:$DROPBOX_PATH $RCLONE_PARAMS --log-file=rclone_backup.log || exit 1
          echo "SSL Certificates backup to Dropbox completed."

      - name: Backup domain list and rclone config
        run: |
          rclone copy cloudflare_domains_list.txt dropbox:$DROPBOX_PATH $RCLONE_PARAMS --log-file=rclone_domainlist.log || exit 1
          rclone copy ~/.config/rclone dropbox:$DROPBOX_PATH/rclone-config $RCLONE_PARAMS --log-file=rclone_config.log || exit 1
          echo "Domain list and rclone config backup to Dropbox completed."

      - name: Cleanup local certificates
        run: |
          rm -rf ./ssl
          echo "Local SSL certificates cleaned up."

      - name: Update GitHub Secrets
        env:
          CLI_TOKEN: ${{ secrets.CLI_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          RCLONE_CONFIG=$(cat ~/.config/rclone/rclone.conf)
          echo "${CLI_TOKEN}" | gh auth login --with-token
          gh secret set RCLONE_CONFIG -b"${RCLONE_CONFIG}" --repo "${REPO}" || { echo "Failed to update RCLONE_CONFIG secret"; exit 1; }
          echo "Updated RCLONE_CONFIG secret."
